//******************************************************************************
//   MSP-FET430P140 Demo - I2C, Master Reads from MSP430 Slave
//
//   Description: This demo connects two MSP430's via the I2C bus. The master
//   reads from the slave. This is the master code. The slave code is called
//   fet140_i2c_05.c. The data from the slave transmitter begins
//   at 0 and is incremented with each transfer. The received data is in RXData
//   and is checked for validity. If the received data is incorrect, the CPU is
//   trapped and the P1.0 LED will stay on. The RXRDYIFG interrupt is used to
//   know when new data has been received.
//   Run the code in Slave device before starting the Master device for proper
//   communication
//   ACLK = n/a, MCLK = SMCLK = I2CCLOCK = DCO ~ 800kHz
//   //* MSP430F169 Device Required *//
//
//                                 /|\  /|\
//                  MSP430F169     10k  10k     MSP430F169
//                    slave         |    |        master
//              -----------------|  |    |  -----------------
//             |             P3.1|<-|---+->|P3.1             |
//             |                 |  |      |             P1.0|-->LED
//             |                 |  |      |                 |
//             |             P3.3|<-+----->|P3.3             |
//             |                 |         |                 |
//
//
//  M. Mitchell
//  Texas Instruments Inc.
//  Feb 2005
//  Built with IAR Embedded Workbench Version: 3.21A
//******************************************************************************

#include  <msp430x16x.h>
#include "i2c.h"

char RXData = 0;
char TestDa0x48ta = 0;


int data[2];
void main (void)
{
  
  osc_init_xt2();
  WDTCTL = WDTPW + WDTHOLD;                 // Stop WDT
 
  CCTL0 = CCIE;             	// CCR0 habilita interrupción del timer
  CCR0 = 32-1;
  
  TACTL = TASSEL_1 + MC_1;    // reloj ACLK, modo up to CCR0
  adc_init_single_channel_single_conv();
  
  
  i2c_init(0x48, I2C_MASTER);

  _BIS_SR(LPM0_bits + GIE);	// modo bajo consumo
  
  
  
  
  _EINT();                                  // Enable interrupts
  
  
    //i2c_master_read(0x01, hola, 2);
    //i2c_master_write(0x02,hola , 2);
  
}
/*
// Common ISR for I2C Module
#pragma vector=USART0TX_VECTOR
__interrupt void I2C_ISR(void)
{
  switch(I2CIV)
  {
  case  0: break;                          // No interrupt
  case  2: break;                          // Arbitration lost
  case  4: break;                          // No Acknowledge
  case  6: break;                          // Own Address
  case  8: break;                          // Register Access Ready
  case 10:                                 // Receive Ready
    RXData = I2CDRB;                       // RX data
    _BIC_SR_IRQ(CPUOFF);                   // Clear LPM0
    break;
  case 12: break;                          // Transmit Ready
  case 14: break;                          // General Call
  case 16: break;                          // Start Condition
  }
}*/
  // Interrupciones 



#define CONV(x)      (3.3*x)/4095.0			// convertir x en voltaje

// Timer A0 rutina de servicio de interrupción
#pragma vector = TIMERA0_VECTOR
__interrupt void Timer_A (void)

{ 
  //adc_single_channel_single_conv_it(1);
  adc_init_seq_channel_single_conv();  
 
  
  i2c_master_write(0x01 , &data[0] , 2);
  
  i2c_master_write(0x02 , &data[1] , 2);
  
  
}
