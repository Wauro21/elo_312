//******************************************************************************

#include  <msp430x16x.h>
#include "i2c.h"

char RXData = 0;
char TestDa0x48ta = 0;


int data[2];
void main (void)
{
  
  osc_init_xt2();
  WDTCTL = WDTPW + WDTHOLD;                 // Stop WDT
 
  CCTL0 = CCIE;             	// CCR0 habilita interrupción del timer
  CCR0 = 1500-1;
  
  TACTL = TASSEL_1 + MC_1;    // reloj ACLK, modo up to CCR0
  adc_init_single_channel_single_conv();
  
  
  i2c_init(0x48, I2C_MASTER);

  _BIS_SR(LPM0_bits + GIE);	// modo bajo consumo
  
  _EINT();                                  // Enable interrupts
  
}
#pragma vector=USART0TX_VECTOR

__interrupt void I2C_ISR(void)
{
  switch(I2CIV)
  {
  case  0: break;                          // No interrupt
  case  2: break;                          // Arbitration lost
  case  4: break;                          // No Acknowledge
  case  6: break;                          // Own Address
  case  8: break;                          // Register Access Ready
  case 10:                                 // Receive Ready
    RXData = I2CDRB;                       // RX data
    _BIC_SR_IRQ(CPUOFF);                   // Clear LPM0
    break;
  case 12: break;                          // Transmit Ready
  case 14: break;                          // General Call
  case 16: break;                          // Start Condition
  }
}


  // Interrupciones 



#define CONV(x)      (3.3*x)/4095.0			// convertir x en voltaje

// Timer A0 rutina de servicio de interrupción

#pragma vector = TIMERA0_VECTOR
__interrupt void Timer_A (void)

{ 
  data[0]=adc_single_channel_single_conv(0);  // hace una conversion analoga a digital y la guarda en el arreglo data
  i2c_master_write(0x22, &data[0] , 2);       // envia la informacion que hay en data[0] al slave
}
